<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding meta -->
    
      
        <meta name="author" content="Nicolas Vanhoren" />
      
        <meta name="description" content="A modern tooling library for asynchronous operations using async/await and promises" />
      
    

    <!-- Adding external script-->
    
      
        <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous" ></script>
      
        <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.min.js" integrity="sha256-KSlsysqp7TXtFo/FHjb1T9b425x3hrvzjMWaJyKbpcI=" crossorigin="anonymous" ></script>
      
        <script src="https://cdn.jsdelivr.net/npm/axios@0.21.0/dist/axios.min.js" integrity="sha256-OPn1YfcEh9W2pwF1iSS+yDk099tYj+plSrCS6Esa9NA=" crossorigin="anonymous" ></script>
      
        <script src="../../inject-script.js" ></script>
      
        <script src="https://www.googletagmanager.com/gtag/js?id=G-707LQFBQY9" ></script>
      
        <script src="../../ga.js" ></script>
      
        <script src="https://cdn.jsdelivr.net/npm/modern-async" ></script>
      
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>Global</title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-light.css">
    
<svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/>
                <path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/>
            </g>
        </symbol>
    </defs>
</svg>

</head>
<body>
<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html"><div class="text">modern-async</div></a></h2><div class="search-box"><input type="text" placeholder="Search..." id="search-box" /><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-list-div"><ul><li><a href='https://github.com/nicolas-van/modern-async' class='' id='' target=''>Github</a></li></ul><h3>Classes</h3><ul><li><a href="CancelledError.html">CancelledError</a></li><li><a href="Deferred.html">Deferred</a></li><li><a href="Delayer.html">Delayer</a><ul class='methods'><li data-type='method'><a href="Delayer.html#checkDelay">checkDelay</a></li><li data-type='method'><a href="Delayer.html#reset">reset</a></li></ul></li><li><a href="Queue.html">Queue</a><ul class='methods'><li data-type='method'><a href="Queue.html#cancelAllPending">cancelAllPending</a></li><li data-type='method'><a href="Queue.html#exec">exec</a></li><li data-type='method'><a href="Queue.html#execCancellable">execCancellable</a></li></ul></li><li><a href="Scheduler.html">Scheduler</a><ul class='methods'><li data-type='method'><a href="Scheduler.html#start">start</a></li><li data-type='method'><a href="Scheduler.html#stop">stop</a></li></ul></li><li><a href="TimeoutError.html">TimeoutError</a></li></ul><h3><a href="global.html">Global</a></h3><ul><li><a href="global.html#asyncIterableWrap">asyncIterableWrap</a></li><li><a href="global.html#asyncRoot">asyncRoot</a></li><li><a href="global.html#asyncWrap">asyncWrap</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#delayCancellable">delayCancellable</a></li><li><a href="global.html#every">every</a></li><li><a href="global.html#everyLimit">everyLimit</a></li><li><a href="global.html#everySeries">everySeries</a></li><li><a href="global.html#filter">filter</a></li><li><a href="global.html#filterGenerator">filterGenerator</a></li><li><a href="global.html#filterLimit">filterLimit</a></li><li><a href="global.html#filterSeries">filterSeries</a></li><li><a href="global.html#find">find</a></li><li><a href="global.html#findIndex">findIndex</a></li><li><a href="global.html#findIndexLimit">findIndexLimit</a></li><li><a href="global.html#findIndexSeries">findIndexSeries</a></li><li><a href="global.html#findLimit">findLimit</a></li><li><a href="global.html#findSeries">findSeries</a></li><li><a href="global.html#forEach">forEach</a></li><li><a href="global.html#forEachLimit">forEachLimit</a></li><li><a href="global.html#forEachSeries">forEachSeries</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#mapGenerator">mapGenerator</a></li><li><a href="global.html#mapLimit">mapLimit</a></li><li><a href="global.html#mapSeries">mapSeries</a></li><li><a href="global.html#queueMicrotask">queueMicrotask</a></li><li><a href="global.html#reduce">reduce</a></li><li><a href="global.html#reduceRight">reduceRight</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#sleepCancellable">sleepCancellable</a></li><li><a href="global.html#sleepPrecise">sleepPrecise</a></li><li><a href="global.html#sleepPreciseCancellable">sleepPreciseCancellable</a></li><li><a href="global.html#some">some</a></li><li><a href="global.html#someLimit">someLimit</a></li><li><a href="global.html#someSeries">someSeries</a></li><li><a href="global.html#timeout">timeout</a></li><li><a href="global.html#timeoutPrecise">timeoutPrecise</a></li><li><a href="global.html#toArray">toArray</a></li></ul></div>
</nav>

<div id="main">
    
    <h1 id='page-title' class="page-title">Global</h1>
    

    




<section>



<article>
    <div class="container-overview">
    
        

        
        
    
    </div>

    

    

    

     

    

    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id="asyncIterableWrap">
        <a href="#asyncIterableWrap">#</a>
        <span class="type-signature">(async, generator) </span>asyncIterableWrap<span class="signature">(iterable)</span><span class="type-signature"></span>
    </h4>

    



    <div class="description">
        <p>Wraps an iterable or async iterable into an iterable that is guaranted to be async.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="asyncIterableWrap.mjs.html">asyncIterableWrap.mjs</a>, <a href="asyncIterableWrap.mjs.html#line27">line 27</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>















    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { asyncIterableWrap } from 'modern-async'

// example sync generator
function* syncGenerator() {
  for (let i = 0; i &lt; 3; i += 1) {
    yield i
  }
}

const asyncIterable = asyncIterableWrap(syncGenerator())

for await (const el of asyncIterable) {
  console.log(el)
}
// will print:
// 0
// 1
// 2</code></pre>

    </div>


        
            

    

    <h4 class="name" id="asyncRoot">
        <a href="#asyncRoot">#</a>
        <span class="type-signature">(async) </span>asyncRoot<span class="signature">(fct, errorHandler<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span>
    </h4>

    



    <div class="description">
        <p>Immediately calls an asynchronous function and redirects to an error handler if it throws an exception.
The error handler is optional, the default one just outputs the error in the console.</p>
<p>This function is trivial but useful when you can't use top-level await for compatibility reasons.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fct</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>An asynchronous function to call.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>errorHandler</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    null
                
                </td>
            

            <td class="description last"><p>A facultative error handler. This function will receive a single argument:
the thrown exception. The default behavior is to output the exception in the console.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="asyncRoot.mjs.html">asyncRoot.mjs</a>, <a href="asyncRoot.mjs.html#line23">line 23</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>















    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { asyncRoot } from 'modern-async'

asyncRoot(async () => {
  // any code using await
}, (e) => {
  console.error("An error occured", e)
  process.exit(-1)
})</code></pre>

    </div>


        
            

    

    <h4 class="name" id="asyncWrap">
        <a href="#asyncWrap">#</a>
        <span class="type-signature"></span>asyncWrap<span class="signature">(fct)</span><span class="type-signature"> &rarr; {function}</span>
    </h4>

    



    <div class="description">
        <p>Wraps a function call that may be synchronous in a function that
is guaranted to be async. This is a stricter version of calling a
function and wrapping its result using <code>Promise.resolve()</code> as the new function also
handles the case where the original function throws an exception.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fct</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The function to wrap.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="asyncWrap.mjs.html">asyncWrap.mjs</a>, <a href="asyncWrap.mjs.html#line23">line 23</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>The wrapped function.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { asyncWrap } from 'modern-async'

const myFunction = () => {
  // any kind of function that may or may not return a promise
}

const asyncFct = asyncWrap(myFunction)

const promise = asyncFct()
console.log(promise instanceof Promise) // prints true</code></pre>

    </div>


        
            

    

    <h4 class="name" id="delay">
        <a href="#delay">#</a>
        <span class="type-signature">(async) </span>delay<span class="signature">()</span><span class="type-signature"> &rarr; {Promise.&lt;void>}</span>
    </h4>

    



    <div class="description">
        <p>A function returning a promise that will be resolved in a later task of the event loop.</p>
<p>This function uses core-js' shim for <code>setImmediate()</code> internally.</p>
    </div>













<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="delay.mjs.html">delay.mjs</a>, <a href="delay.mjs.html#line17">line 17</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved on a later tick of the event loop.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;void></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { delay } from 'modern-async'

console.log('this executes in a tick of the event loop')
await delay()
console.log('this executes in another tick of the event loop')</code></pre>

    </div>


        
            

    

    <h4 class="name" id="delayCancellable">
        <a href="#delayCancellable">#</a>
        <span class="type-signature"></span>delayCancellable<span class="signature">()</span><span class="type-signature"> &rarr; {Array}</span>
    </h4>

    



    <div class="description">
        <p>A function returning a promise that will be resolved in a later tick of the event loop.</p>
<p>This function returns both a promise and cancel function in order to cancel the wait time if
necessary. If cancelled, the promise will be rejected with a CancelledError.</p>
<p>This function uses core-js' shim for <code>setImmediate()</code> internally.</p>
    </div>













<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="delayCancellable.mjs.html">delayCancellable.mjs</a>, <a href="delayCancellable.mjs.html#line30">line 30</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A tuple of two objects:</p>
<ul>
<li>The promise</li>
<li>The cancel function. It will return a boolean that will be true if the promise was effectively cancelled,
false otherwise.</li>
</ul>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Array</span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { delayCancellable, CancelledError } from 'modern-async'

const [promise, cancel] = delayCancellable()
cancel()
try {
  await promise
} catch (e) {
  console.log(e instanceof CancelledError) // prints true
}</code></pre>

    </div>


        
            

    

    <h4 class="name" id="every">
        <a href="#every">#</a>
        <span class="type-signature">(async) </span>every<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean>}</span>
    </h4>

    



    <div class="description">
        <p>Returns <code>true</code> if all elements of an iterable pass a truth test and <code>false</code> otherwise.</p>
<p>The iteratee will be run in parallel. If any truth test returns <code>false</code> the promise is immediately resolved.</p>
<p>In case of exception in one of the iteratee calls the promise returned by this function will be rejected
with the exception. In the very specific case where a test returns <code>false</code> and an already started task throws
an exception that exception will be plainly ignored.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="every.mjs.html">every.mjs</a>, <a href="every.mjs.html#line35">line 35</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved to <code>true</code> if all values pass the truth test and <code>false</code>
if a least one of them doesn't pass it. That promise will be rejected if one of the truth test throws
an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;boolean></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { every, sleep } from 'modern-async'

const array = [1, 2, 3]

const result = await every(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(10) // waits 10ms
  return v > 0
})
console.log(result) // prints true
// total processing time should be ~ 10ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="everyLimit">
        <a href="#everyLimit">#</a>
        <span class="type-signature">(async) </span>everyLimit<span class="signature">(iterable, iteratee, queueOrConcurrency)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean>}</span>
    </h4>

    



    <div class="description">
        <p>Returns <code>true</code> if all elements of an iterable pass a truth test and <code>false</code> otherwise.</p>
<p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls.
If any truth test returns <code>false</code> the promise is immediately resolved.</p>
<p>Whenever a test returns <code>false</code>, all the remaining tasks will be cancelled as long
as they didn't started already. In case of exception in one of the iteratee calls the promise
returned by this function will be rejected with the exception and the remaining pending
tasks will also be cancelled. In the very specific case where a test returns <code>false</code> and an
already started task throws an exception that exception will be plainly ignored.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>queueOrConcurrency</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="Queue.html">Queue</a></span>
|

<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>If a queue is specified it will be used to schedule the calls to
<code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created
implicitly for the same purpose.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="everyLimit.mjs.html">everyLimit.mjs</a>, <a href="everyLimit.mjs.html#line45">line 45</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved to <code>true</code> if all values pass the truth test and <code>false</code>
if a least one of them doesn't pass it. That promise will be rejected if one of the truth test throws
an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;boolean></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { everyLimit, sleep } from 'modern-async'

const array = [1, 2, 3]

const result = await everyLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 2
  // concurrent calls
  await sleep(10) // waits 10ms
  return v > 0
}, 2)
console.log(result) // prints true
// total processing time should be ~ 20ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="everySeries">
        <a href="#everySeries">#</a>
        <span class="type-signature">(async) </span>everySeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean>}</span>
    </h4>

    



    <div class="description">
        <p>Returns <code>true</code> if all elements of an iterable pass a truth test and <code>false</code> otherwise.</p>
<p>The iteratee will be run sequentially. If any truth test returns <code>false</code> the promise is
immediately resolved.</p>
<p>In case of exception in one of the iteratee calls the promise returned by this function will be
rejected with the exception and the remaining pending tasks will be cancelled.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="everySeries.mjs.html">everySeries.mjs</a>, <a href="everySeries.mjs.html#line35">line 35</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved to <code>true</code> if all values pass the truth test and <code>false</code>
if a least one of them doesn't pass it. That promise will be rejected if one of the truth test throws
an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;boolean></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { everySeries, sleep } from 'modern-async'

const array = [1, 2, 3]

const result = await everySeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(10) // waits 10ms
  return v > 0
})
console.log(result) // prints true
// total processing time should be ~ 30ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="filter">
        <a href="#filter">#</a>
        <span class="type-signature">(async) </span>filter<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span>
    </h4>

    



    <div class="description">
        <p>Returns an array of all the values in <code>iterable</code> which pass an asynchronous truth test.</p>
<p>The calls to <code>iteratee</code> will perform in parallel. The results will be in the same order than in <code>iterable</code>.</p>
<p>If any of the calls to <code>iteratee</code> throws an exception the returned promise will be rejected.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of <code>iterable</code>. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="filter.mjs.html">filter.mjs</a>, <a href="filter.mjs.html#line32">line 32</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with an array containing all the values that passed
the truth test. This promise will be rejected if any of the <code>iteratee</code> calls throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;Array.&lt;any>></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { filter, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await filter(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(10) // waits 10ms
  return v % 2 === 1
})
console.log(result) // prints [1, 3]
// total processing time should be ~ 10ms
})</code></pre>

    </div>


        
            

    

    <h4 class="name" id="filterGenerator">
        <a href="#filterGenerator">#</a>
        <span class="type-signature">(async, generator) </span>filterGenerator<span class="signature">(iterable, iteratee, queueOrConcurrency<span class="signature-attributes">opt</span>, ordered<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span>
    </h4>

    



    <div class="description">
        <p>Produces a an async iterator that will return each value or <code>iterable</code> which pass an asynchronous truth test.</p>
<p>The iterator will perform the calls to <code>iteratee</code> in a queue to limit the concurrency of
these calls. The iterator will consume values from <code>iterable</code> only if slots are available in the
queue.</p>
<p>If the returned iterator is not fully consumed it will stop consuming new values from <code>iterable</code> and scheduling
new calls to <code>iteratee</code> in the queue, but already scheduled tasks will still be executed.</p>
<p>If <code>iterable</code> or any of the calls to <code>iteratee</code> throws an exception all pending tasks will be cancelled and the
returned async iterator will throw that exception.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>queueOrConcurrency</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="Queue.html">Queue</a></span>
|

<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    1
                
                </td>
            

            <td class="description last"><p>If a queue is specified it will be used to schedule the calls to
<code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created
implicitly for the same purpose.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>ordered</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    true
                
                </td>
            

            <td class="description last"><p>If true the results will be yielded in the same order as in the source
iterable, regardless of which calls to iteratee returned first. If false the the results will be yielded as soon
as a call to iteratee returned.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="filterGenerator.mjs.html">filterGenerator.mjs</a>, <a href="filterGenerator.mjs.html#line50">line 50</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>















    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import {filterGenerator, sleep} from 'modern-async'

const iterator = function * () {
  for (let i = 0; i &lt; 10000; i += 1) {
    yield i
  }
}
const filterIterator = filterGenerator(iterator(), async (v) => {
  await sleep(1000)
  return v % 3 === 0
})
for await (const el of filterIterator) {
  console.log(el)
}
// will print "0", "3", "6", etc... Only one number will be printed every 3 seconds.</code></pre>

    </div>


        
            

    

    <h4 class="name" id="filterLimit">
        <a href="#filterLimit">#</a>
        <span class="type-signature">(async) </span>filterLimit<span class="signature">(iterable, iteratee, queueOrConcurrency)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span>
    </h4>

    



    <div class="description">
        <p>Returns an array of all the values in <code>iterable</code> which pass an asynchronous truth test.</p>
<p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls.
The results will be in the same order than in <code>iterable</code>.</p>
<p>If any of the calls to <code>iteratee</code> throws an exception the returned promise will be rejected and the remaining
pending tasks will be cancelled.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of <code>iterable</code>. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>queueOrConcurrency</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="Queue.html">Queue</a></span>
|

<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>If a queue is specified it will be used to schedule the calls to
<code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created
implicitly for the same purpose.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="filterLimit.mjs.html">filterLimit.mjs</a>, <a href="filterLimit.mjs.html#line39">line 39</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with an array containing all the values that passed
the truth test. This promise will be rejected if any of the <code>iteratee</code> calls throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;Array.&lt;any>></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { filterLimit, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await filterLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 2
  // concurrent calls
  await sleep(10) // waits 10ms
  return v % 2 === 1
}, 2)
console.log(result) // prints [1, 3]
// total processing time should be ~ 20ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="filterSeries">
        <a href="#filterSeries">#</a>
        <span class="type-signature">(async) </span>filterSeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span>
    </h4>

    



    <div class="description">
        <p>Returns an array of all the values in <code>iterable</code> which pass an asynchronous truth test.</p>
<p>The calls to <code>iteratee</code> will perform sequentially. The results will be in the same order than in <code>iterable</code>.</p>
<p>If any of the calls to <code>iteratee</code> throws an exception the returned promise will be rejected and the remaining
pending tasks will be cancelled.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="filterSeries.mjs.html">filterSeries.mjs</a>, <a href="filterSeries.mjs.html#line33">line 33</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with an array containing all the values that passed
the truth test. This promise will be rejected if any of the <code>iteratee</code> calls throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;Array.&lt;any>></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { filterSeries, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await filterSeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(10) // waits 10ms
  return v % 2 === 1
})
console.log(result) // prints [1, 3]
// total processing time should be ~ 30ms
})</code></pre>

    </div>


        
            

    

    <h4 class="name" id="find">
        <a href="#find">#</a>
        <span class="type-signature">(async) </span>find<span class="signature">(iterable, iteratee, ordered<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Promise.&lt;(any|undefined)>}</span>
    </h4>

    



    <div class="description">
        <p>Returns the first element of an iterable that passes an asynchronous truth test.</p>
<p>The calls to <code>iteratee</code> will run in parallel.</p>
<p>In case of exception in one of the <code>iteratee</code> calls the promise returned by this function will be
rejected with the exception. In the very specific case where a result is found and an
already started task throws an exception that exception will be plainly ignored.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>ordered</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    false
                
                </td>
            

            <td class="description last"><p>If true this function will return on the first element in the iterable
order for which <code>iteratee</code> returned true. If false it will be the first in time.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="find.mjs.html">find.mjs</a>, <a href="find.mjs.html#line34">line 34</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with the first found value or rejected if one of the
<code>iteratee</code> calls throws an exception before finding a value. If no value is found it will return <code>undefined</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;(any|undefined)></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { find, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await find(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  return v % 2 === 1
})
console.log(result) // prints 1</code></pre>

    </div>


        
            

    

    <h4 class="name" id="findIndex">
        <a href="#findIndex">#</a>
        <span class="type-signature">(async) </span>findIndex<span class="signature">(iterable, iteratee, ordered<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Promise.&lt;number>}</span>
    </h4>

    



    <div class="description">
        <p>Returns the index of the first element of an iterable that passes an asynchronous truth test.</p>
<p>The calls to <code>iteratee</code> will run in parallel.</p>
<p>In case of exception in one of the <code>iteratee</code> calls the promise returned by this function will be
rejected with the exception. In the very specific case where a result is found and an
already started task throws an exception that exception will be plainly ignored.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>ordered</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    false
                
                </td>
            

            <td class="description last"><p>If true this function will return on the first element in the iterable
order for which <code>iteratee</code> returned true. If false it will be the first in time.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="findIndex.mjs.html">findIndex.mjs</a>, <a href="findIndex.mjs.html#line34">line 34</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with the index of the first found value or rejected if one of the
<code>iteratee</code> calls throws an exception before finding a value. If no value is found it will return <code>-1</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;number></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { findIndex, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await findIndex(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  return v % 2 === 1
})
console.log(result) // prints 0</code></pre>

    </div>


        
            

    

    <h4 class="name" id="findIndexLimit">
        <a href="#findIndexLimit">#</a>
        <span class="type-signature">(async) </span>findIndexLimit<span class="signature">(iterable, iteratee, queueOrConcurrency, ordered<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Promise.&lt;number>}</span>
    </h4>

    



    <div class="description">
        <p>Returns the index of the first element of an iterable that passes an asynchronous truth test.</p>
<p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls.</p>
<p>Whenever a result is found, all the remaining tasks will be cancelled as long
as they didn't started already. In case of exception in one of the iteratee calls the promise
returned by this function will be rejected with the exception and the remaining pending
tasks will also be cancelled. In the very specific case where a result is found and an
already started task throws an exception that exception will be plainly ignored.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>queueOrConcurrency</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="Queue.html">Queue</a></span>
|

<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>If a queue is specified it will be used to schedule the calls to
<code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created
implicitly for the same purpose.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>ordered</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    false
                
                </td>
            

            <td class="description last"><p>If true this function will return on the first element in the iterable
order for which <code>iteratee</code> returned true. If false it will be the first in time.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="findIndexLimit.mjs.html">findIndexLimit.mjs</a>, <a href="findIndexLimit.mjs.html#line41">line 41</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with the index of the first found value or rejected if one of the
<code>iteratee</code> calls throws an exception before finding a value. If no value is found it will return <code>-1</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;number></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { findIndexLimit, sleep } from 'modern-async'

const array = [1, 2, 3, 4, 5]
const result = await findIndexLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 3
  // concurrent calls
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  return v % 2 === 1
}, 3)
console.log(result) // prints 0</code></pre>

    </div>


        
            

    

    <h4 class="name" id="findIndexSeries">
        <a href="#findIndexSeries">#</a>
        <span class="type-signature">(async) </span>findIndexSeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;number>}</span>
    </h4>

    



    <div class="description">
        <p>Returns the index of the first element of an iterable that passes an asynchronous truth test.</p>
<p>The calls to <code>iteratee</code> will run sequentially.</p>
<p>In case of exception in one of the <code>iteratee</code> calls the promise returned by this function will be
rejected with the exception and the remaining pending tasks will be cancelled.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="findIndexSeries.mjs.html">findIndexSeries.mjs</a>, <a href="findIndexSeries.mjs.html#line31">line 31</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with the index of the first found value or rejected if one of the
<code>iteratee</code> calls throws an exception before finding a value. If no value is found it will return <code>-1</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;number></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { findIndexSeries, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await findIndexSeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  return v % 2 === 1
})
console.log(result) // prints 0</code></pre>

    </div>


        
            

    

    <h4 class="name" id="findLimit">
        <a href="#findLimit">#</a>
        <span class="type-signature">(async) </span>findLimit<span class="signature">(iterable, iteratee, queueOrConcurrency, ordered<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Promise.&lt;(any|undefined)>}</span>
    </h4>

    



    <div class="description">
        <p>Returns the first element of an iterable that passes an asynchronous truth test.</p>
<p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls.</p>
<p>Whenever a result is found, all the remaining tasks will be cancelled as long
as they didn't started already. In case of exception in one of the <code>iteratee</code> calls the promise
returned by this function will be rejected with the exception and the remaining pending
tasks will also be cancelled. In the very specific case where a result is found and an
already started task throws an exception that exception will be plainly ignored.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>queueOrConcurrency</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="Queue.html">Queue</a></span>
|

<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>If a queue is specified it will be used to schedule the calls to
<code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created
implicitly for the same purpose.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>ordered</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    false
                
                </td>
            

            <td class="description last"><p>If true this function will return on the first element in the iterable
order for which <code>iteratee</code> returned true. If false it will be the first in time.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="findLimit.mjs.html">findLimit.mjs</a>, <a href="findLimit.mjs.html#line41">line 41</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with the first found value or rejected if one of the
<code>iteratee</code> calls throws an exception before finding a value. If no value is found it will return <code>undefined</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;(any|undefined)></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { findLimit, sleep } from 'modern-async'

const array = [1, 2, 3, 4, 5]
const result = await findLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 3
  // concurrent calls
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  return v % 2 === 1
}, 3)
console.log(result) // prints 1</code></pre>

    </div>


        
            

    

    <h4 class="name" id="findSeries">
        <a href="#findSeries">#</a>
        <span class="type-signature">(async) </span>findSeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;(any|undefined)>}</span>
    </h4>

    



    <div class="description">
        <p>Returns the first element of an iterable that passes an asynchronous truth test.</p>
<p>The calls to <code>iteratee</code> will run sequentially.</p>
<p>In case of exception in one of the <code>iteratee</code> calls the promise returned by this function will be
rejected with the exception and the remaining pending tasks will be cancelled.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="findSeries.mjs.html">findSeries.mjs</a>, <a href="findSeries.mjs.html#line31">line 31</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with the first found value or rejected if one of the
<code>iteratee</code> calls throws an exception before finding a value. If no value is found it will return <code>undefined</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;(any|undefined)></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { findSeries, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await findSeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  return v % 2 === 1
})
console.log(result) // prints 1</code></pre>

    </div>


        
            

    

    <h4 class="name" id="forEach">
        <a href="#forEach">#</a>
        <span class="type-signature">(async) </span>forEach<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise}</span>
    </h4>

    



    <div class="description">
        <p>Calls a function on each element of iterable.</p>
<p>Multiple calls to <code>iteratee</code> will be performed in parallel.</p>
<p>If any of the calls to iteratee throws an exception the returned promise will be rejected.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="forEach.mjs.html">forEach.mjs</a>, <a href="forEach.mjs.html#line31">line 31</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved when all the calls to <code>iteratee</code> have been done.
This promise will be rejected if any call to <code>iteratee</code> throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise</span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { forEach, sleep } from 'modern-async'

const array = [1, 2, 3]
await forEach(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  console.log(v)
})
// prints 1, 2 and 3 in a random order
})</code></pre>

    </div>


        
            

    

    <h4 class="name" id="forEachLimit">
        <a href="#forEachLimit">#</a>
        <span class="type-signature">(async) </span>forEachLimit<span class="signature">(iterable, iteratee, queueOrConcurrency)</span><span class="type-signature"> &rarr; {Promise}</span>
    </h4>

    



    <div class="description">
        <p>Calls a function on each element of iterable.</p>
<p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls.</p>
<p>If any of the calls to iteratee throws an exception the returned promise will be rejected and the remaining
pending tasks will be cancelled.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>queueOrConcurrency</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="Queue.html">Queue</a></span>
|

<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>If a queue is specified it will be used to schedule the calls to
<code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created
implicitly for the same purpose.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="forEachLimit.mjs.html">forEachLimit.mjs</a>, <a href="forEachLimit.mjs.html#line37">line 37</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved when all the calls to <code>iteratee</code> have been done.
This promise will be rejected if any call to <code>iteratee</code> throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise</span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { forEachLimit, sleep } from 'modern-async'

const array = [1, 2, 3]
await forEachLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 2
  // concurrent calls
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  console.log(v)
}, 2)
// prints 1, 2 and 3 in a random order (it will always print 1 or 2 before printing 3 due to
// the concurrency limit and the internal scheduling order)</code></pre>

    </div>


        
            

    

    <h4 class="name" id="forEachSeries">
        <a href="#forEachSeries">#</a>
        <span class="type-signature">(async) </span>forEachSeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise}</span>
    </h4>

    



    <div class="description">
        <p>Calls a function on each element of iterable.</p>
<p>Multiple calls to <code>iteratee</code> will be performed sequentially.</p>
<p>If any of the calls to iteratee throws an exception the returned promise will be rejected and the remaining
pending tasks will be cancelled.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="forEachSeries.mjs.html">forEachSeries.mjs</a>, <a href="forEachSeries.mjs.html#line31">line 31</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved when all the calls to <code>iteratee</code> have been done.
This promise will be rejected if any call to <code>iteratee</code> throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise</span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { forEachSeries, sleep } from 'modern-async'

const array = [1, 2, 3]
await forEachSeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(Math.random() * 10) // waits a random amount of time between 0ms and 10ms
  console.log(v)
})
// prints 1, 2 and 3 in that exact order</code></pre>

    </div>


        
            

    

    <h4 class="name" id="map">
        <a href="#map">#</a>
        <span class="type-signature">(async) </span>map<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span>
    </h4>

    



    <div class="description">
        <p>Produces a new collection of values by mapping each value in <code>iterable</code> through the <code>iteratee</code> function.</p>
<p>Multiple calls to <code>iteratee</code> will be performed in parallel.</p>
<p>If any of the calls to iteratee throws an exception the returned promise will be rejected.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="map.mjs.html">map.mjs</a>, <a href="map.mjs.html#line31">line 31</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with an array containing all the mapped value,
or will be rejected if any of the calls to <code>iteratee</code> throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;Array.&lt;any>></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { map, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await map(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(10) // waits 10ms
  return v * 2
})
console.log(result) // prints [2, 4, 6]
// total processing time should be ~ 10ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="mapGenerator">
        <a href="#mapGenerator">#</a>
        <span class="type-signature">(async, generator) </span>mapGenerator<span class="signature">(iterable, iteratee, queueOrConcurrency<span class="signature-attributes">opt</span>, ordered<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span>
    </h4>

    



    <div class="description">
        <p>Produces a an async iterator that will return each value or <code>iterable</code> after having processed them through
the <code>iteratee</code> function.</p>
<p>The iterator will perform the calls to <code>iteratee</code> in a queue to limit the concurrency of
these calls. The iterator will consume values from <code>iterable</code> only if slots are available in the
queue.</p>
<p>If the returned iterator is not fully consumed it will stop consuming new values from <code>iterable</code> and scheduling
new calls to <code>iteratee</code> in the queue, but already scheduled tasks will still be executed.</p>
<p>If <code>iterable</code> or any of the calls to <code>iteratee</code> throws an exception all pending tasks will be cancelled and the
returned async iterator will throw that exception.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>queueOrConcurrency</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="Queue.html">Queue</a></span>
|

<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    1
                
                </td>
            

            <td class="description last"><p>If a queue is specified it will be used to schedule the calls to
<code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created
implicitly for the same purpose.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>ordered</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    true
                
                </td>
            

            <td class="description last"><p>If true the results will be yielded in the same order as in the source
iterable, regardless of which calls to iteratee returned first. If false the the results will be yielded as soon
as a call to iteratee returned.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="mapGenerator.mjs.html">mapGenerator.mjs</a>, <a href="mapGenerator.mjs.html#line53">line 53</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>















    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import {mapGenerator, sleep} from 'modern-async'

const iterator = function * () {
  for (let i = 0; i &lt; 10000; i += 1) {
    yield i
  }
}
const mapIterator = mapGenerator(iterator(), async (v) => {
  await sleep(1000)
  return v * 2
})
for await (const el of mapIterator) {
  console.log(el)
}
// Will print "0", "2", "4", etc... Only one number will be printed per second.
// Numbers from `iterator` will be consumed progressively</code></pre>

    </div>


        
            

    

    <h4 class="name" id="mapLimit">
        <a href="#mapLimit">#</a>
        <span class="type-signature">(async) </span>mapLimit<span class="signature">(iterable, iteratee, queueOrConcurrency)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span>
    </h4>

    



    <div class="description">
        <p>Produces a new collection of values by mapping each value in <code>iterable</code> through the <code>iteratee</code> function.</p>
<p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls.</p>
<p>If any of the calls to iteratee throws an exception the returned promise will be rejected and the remaining
pending tasks will be cancelled.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>queueOrConcurrency</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="Queue.html">Queue</a></span>
|

<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>If a queue is specified it will be used to schedule the calls to
<code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created
implicitly for the same purpose.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="mapLimit.mjs.html">mapLimit.mjs</a>, <a href="mapLimit.mjs.html#line38">line 38</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with an array containing all the mapped value,
or will be rejected if any of the calls to <code>iteratee</code> throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;Array.&lt;any>></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { mapLimit, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await mapLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 2
  // concurrent calls
  await sleep(10) // waits 10ms
  return v * 2
}, 2)
console.log(result) // prints [2, 4, 6]
// total processing time should be ~ 20ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="mapSeries">
        <a href="#mapSeries">#</a>
        <span class="type-signature">(async) </span>mapSeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span>
    </h4>

    



    <div class="description">
        <p>Produces a new collection of values by mapping each value in <code>iterable</code> through the <code>iteratee</code> function.</p>
<p>Multiple calls to <code>iteratee</code> will be performed sequentially.</p>
<p>If any of the calls to iteratee throws an exception the returned promise will be rejected and the remaining
pending tasks will be cancelled.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="mapSeries.mjs.html">mapSeries.mjs</a>, <a href="mapSeries.mjs.html#line32">line 32</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with an array containing all the mapped value,
or will be rejected if any of the calls to <code>iteratee</code> throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;Array.&lt;any>></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { mapSeries, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await mapSeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(10) // waits 10ms
  return v * 2
}, 2)
console.log(result) // prints [2, 4, 6]
// total processing time should be ~ 30ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="queueMicrotask">
        <a href="#queueMicrotask">#</a>
        <span class="type-signature"></span>queueMicrotask<span class="signature">(fct)</span><span class="type-signature"></span>
    </h4>

    



    <div class="description">
        <p>An alternative to standard <code>queueMicrotask()</code> function.</p>
<p>This is just of mirror of core-js' implementation for compatibility.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fct</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The function to call in a microtask.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="queueMicrotask.mjs.html">queueMicrotask.mjs</a>, <a href="queueMicrotask.mjs.html#line17">line 17</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>















    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { queueMicrotask } from 'modern-async'

queueMicrotask(() => {
  console.log('this resolves in a micro task')
})</code></pre>

    </div>


        
            

    

    <h4 class="name" id="reduce">
        <a href="#reduce">#</a>
        <span class="type-signature">(async) </span>reduce<span class="signature">(iterable, reducer, initial<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Promise}</span>
    </h4>

    



    <div class="description">
        <p>Performs a reduce operation as defined in the <code>Array.reduce()</code> method but using an asynchronous
function as reducer. The reducer will be called sequentially.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reducer</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last"><p>The reducer function. It will be called with four arguments:</p>
<ul>
<li><code>accumulator</code>: The last calculated value (or the first value of the iterable if no initial value is provided)</li>
<li><code>value</code>: The current value</li>
<li><code>index</code>: The current index in the iterable. Will start from 0 if no initial value is provided, 1 otherwise.</li>
<li><code>iterable</code>: The iterable on which the reduce operation is performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>initial</code></td>
            

            <td class="type">
            
                
<span class="param-type">any</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last"><p>The initial value that will be used as accumulator in the first call to
<code>reducer</code>. If omitted the first element of <code>iterable</code> will be used as accumulator and <code>reducer</code>
will only be called from from the second element of the list (as defined in the <code>Array.reduce()</code>
function).</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="reduce.mjs.html">reduce.mjs</a>, <a href="reduce.mjs.html#line33">line 33</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with the result of the reduce operation,
or rejected if any of the calls to <code>reducer</code> throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise</span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { reduce, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await reduce(array, async (v, p) => {
  // these calls will be performed sequentially
  await sleep(10) // waits 10ms
  return v + p
})
console.log(result) // prints 6
// total processing time should be ~ 20ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="reduceRight">
        <a href="#reduceRight">#</a>
        <span class="type-signature">(async) </span>reduceRight<span class="signature">(iterable, reducer, initial<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {Promise}</span>
    </h4>

    



    <div class="description">
        <p>Performs a reduce operation as defined in the <code>Array.reduceRight()</code> method but using an asynchronous
function as reducer. The reducer will be called sequentially.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last"><p>An iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reducer</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last"><p>The reducer function. It will be called with four arguments:</p>
<ul>
<li><code>accumulator</code>: The last calculated value (or the first value of the iterable if no initial value is provided)</li>
<li><code>value</code>: The current value</li>
<li><code>index</code>: The current index in the iterable. Will start from the last index if no initial value is provided,
the last index minus 1 otherwise.</li>
<li><code>iterable</code>: The iterable on which the reduce operation is performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>initial</code></td>
            

            <td class="type">
            
                
<span class="param-type">any</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last"><p>The initial value that will be used as accumulator in the first call to
reducer. If omitted the first element of <code>iterable</code> will be used as accumulator and <code>reducer</code>
will only be called from from the second element of the list (as defined in the <code>Array.reduce()</code>
function).</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="reduceRight.mjs.html">reduceRight.mjs</a>, <a href="reduceRight.mjs.html#line35">line 35</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved with the result of the reduce operation,
or rejected if any of the calls to <code>reducer</code> throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise</span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { reduceRight, sleep } from 'modern-async'

const array = [1, 2, 3]
const result = await reduceRight(array, async (v, p) => {
  // these calls will be performed sequentially
  await sleep(10) // waits 10ms
  return v + p
})
console.log(result) // prints 6
// total processing time should be ~ 20ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="sleep">
        <a href="#sleep">#</a>
        <span class="type-signature">(async) </span>sleep<span class="signature">(amount)</span><span class="type-signature"> &rarr; {Promise.&lt;void>}</span>
    </h4>

    



    <div class="description">
        <p>Waits a given amount of time.</p>
<p>This function uses <code>setTimeout()</code> internally and has the same behavior, notably that it could resolve
after the asked time (depending on other tasks running in the event loop) or a few milliseconds before.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>amount</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>An amount of time in milliseconds</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="sleep.mjs.html">sleep.mjs</a>, <a href="sleep.mjs.html#line26">line 26</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved after the given amount of time has passed.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;void></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Examples</strong>
        
    <pre class="prettyprint"><code>import { sleep } from 'modern-async'

await sleep(100) // will wait 100ms</code></pre>

    <pre class="prettyprint"><code>// another example that doesn't block on the sleep call
// it's functionally identical to using setTimout but with a promise syntax
import { sleep } from 'modern-async'

sleep(10).then(() => {
  console.log('hello')
})
// will print 'hello' after 10ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="sleepCancellable">
        <a href="#sleepCancellable">#</a>
        <span class="type-signature"></span>sleepCancellable<span class="signature">(amount)</span><span class="type-signature"> &rarr; {Array}</span>
    </h4>

    



    <div class="description">
        <p>Waits a given amount of time. This function returns both a promise and cancel function in
order to cancel the wait time if necessary. If cancelled, the promise will be rejected
with a <code>CancelledError</code>.</p>
<p>This function uses <code>setTimeout()</code> internally and has the same behavior, notably that it could resolve
after the asked time (depending on other tasks running in the event loop) or a few milliseconds before.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>amount</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>An amount of time in milliseconds</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="sleepCancellable.mjs.html">sleepCancellable.mjs</a>, <a href="sleepCancellable.mjs.html#line32">line 32</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A tuple of two objects:</p>
<ul>
<li><code>promise</code>: The promise</li>
<li><code>cancel</code>: The cancel function. It will return a boolean that will be <code>true</code> if the promise was effectively cancelled,
<code>false</code> otherwise.</li>
</ul>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Array</span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { sleepCancellable } from 'modern-async'

const [promise, cancel] = sleepCancellable(100) // schedule to resolve the promise after 100ms

cancel()

try {
  await promise
} catch (e) {
  console.log(e.name) // prints CancelledError
}</code></pre>

    </div>


        
            

    

    <h4 class="name" id="sleepPrecise">
        <a href="#sleepPrecise">#</a>
        <span class="type-signature">(async) </span>sleepPrecise<span class="signature">(amount)</span><span class="type-signature"> &rarr; {Promise.&lt;void>}</span>
    </h4>

    



    <div class="description">
        <p>Waits a given amount of time.</p>
<p>This function is similar to <code>sleep()</code> except it ensures that the amount of time measured
using the <code>Date</code> object is always greater than or equal the asked amount of time.</p>
<p>This function can imply additional delay that can be bad for performances. As such it is
recommended to only use it in unit tests or very specific cases. Most applications should
be adapted to work with the usual <code>setTimout()</code> inconsistencies even if it can trigger some
milliseconds before the asked delay.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>amount</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>An amount of time in milliseconds</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="sleepPrecise.mjs.html">sleepPrecise.mjs</a>, <a href="sleepPrecise.mjs.html#line22">line 22</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved after the given amount of time has passed.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;void></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { sleepPrecise } from 'modern-async'

await sleepPrecise(100) // will wait 100ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="sleepPreciseCancellable">
        <a href="#sleepPreciseCancellable">#</a>
        <span class="type-signature"></span>sleepPreciseCancellable<span class="signature">(amount)</span><span class="type-signature"> &rarr; {Array}</span>
    </h4>

    



    <div class="description">
        <p>Waits a given amount of time.</p>
<p>This function returns both a promise and cancel function in order to cancel the
wait time if necessary. If cancelled, the promise will be rejected with a <code>CancelledError</code>.</p>
<p>This function is similar to <code>sleep()</code> except it ensures that the amount of time measured
using the <code>Date</code> object is always greater than or equal the asked amount of time.</p>
<p>This function can imply additional delay that can be bad for performances. As such it is
recommended to only use it in unit tests or very specific cases. Most applications should
be adapted to work with the usual <code>setTimout()</code> inconsistencies even if it can trigger some
milliseconds before the asked delay.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>amount</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>An amount of time in milliseconds</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="sleepPreciseCancellable.mjs.html">sleepPreciseCancellable.mjs</a>, <a href="sleepPreciseCancellable.mjs.html#line38">line 38</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A tuple of two objects:</p>
<ul>
<li><code>promise</code>: The promise</li>
<li><code>cancel</code>: The cancel function. It will return a boolean that will be <code>true</code> if the promise was effectively cancelled,
<code>false</code> otherwise.</li>
</ul>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Array</span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { sleepPreciseCancellable } from 'modern-async'

const [promise, cancel] = sleepPreciseCancellable(100) // schedule to resolve the promise after 100ms

cancel()

try {
  await promise
} catch (e) {
  console.log(e.name) // prints CancelledError
}</code></pre>

    </div>


        
            

    

    <h4 class="name" id="some">
        <a href="#some">#</a>
        <span class="type-signature">(async) </span>some<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean>}</span>
    </h4>

    



    <div class="description">
        <p>Returns <code>true</code> if at least one element of an iterable pass a truth test and <code>false</code> otherwise.</p>
<p>The calls to <code>iteratee</code> will run in parallel. If any truth test returns <code>true</code> the promise is immediately resolved.</p>
<p>In case of exception in one of the <code>iteratee</code> calls the promise returned by this function will be rejected
with the exception. In the very specific case where a test returns <code>true</code> and an already started task throws
an exception that exception will be plainly ignored.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="some.mjs.html">some.mjs</a>, <a href="some.mjs.html#line34">line 34</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved to <code>true</code> if at least one value pass the truth test and <code>false</code>
if none of them do. That promise will be rejected if one of the truth test throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;boolean></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { some, sleep } from 'modern-async'

const array = [1, 2, 3]

const result = await some(array, async (v) => {
  // these calls will be performed in parallel
  await sleep(10) // waits 10ms
  return v % 2 === 0
})
console.log(result) // prints true
// total processing time should be ~ 10ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="someLimit">
        <a href="#someLimit">#</a>
        <span class="type-signature">(async) </span>someLimit<span class="signature">(iterable, iteratee, queueOrConcurrency)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean>}</span>
    </h4>

    



    <div class="description">
        <p>Returns <code>true</code> if at least one element of an iterable pass a truth test and <code>false</code> otherwise.</p>
<p>The calls to <code>iteratee</code> will be performed in a queue to limit the concurrency of these calls. If any
truth test returns <code>true</code> the promise is immediately resolved.</p>
<p>Whenever a test returns <code>true</code>, all the remaining tasks will be cancelled as long
as they didn't started already. In case of exception in one of the <code>iteratee</code> calls the promise
returned by this function will be rejected with the exception and the remaining pending
tasks will also be cancelled. In the very specific case where a test returns <code>true</code> and an
already started task throws an exception that exception will be plainly ignored.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>queueOrConcurrency</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="Queue.html">Queue</a></span>
|

<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>If a queue is specified it will be used to schedule the calls to
<code>iteratee</code>. If a number is specified it will be used as the concurrency of a Queue that will be created
implicitly for the same purpose.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="someLimit.mjs.html">someLimit.mjs</a>, <a href="someLimit.mjs.html#line42">line 42</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved to <code>true</code> if at least one value pass the truth test and <code>false</code>
if none of them do. That promise will be rejected if one of the truth test throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;boolean></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { someLimit, sleep } from 'modern-async'

const array = [1, 2, 3]

const result = await someLimit(array, async (v) => {
  // these calls will be performed in parallel with a maximum of 2
  // concurrent calls
  await sleep(10) // waits 10ms
  return v % 2 === 0
}, 2)
console.log(result) // prints true
// total processing time should be ~ 10ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="someSeries">
        <a href="#someSeries">#</a>
        <span class="type-signature">(async) </span>someSeries<span class="signature">(iterable, iteratee)</span><span class="type-signature"> &rarr; {Promise.&lt;boolean>}</span>
    </h4>

    



    <div class="description">
        <p>Returns <code>true</code> if all elements of an iterable pass a truth test and <code>false</code> otherwise.</p>
<p>The calls to <code>iteratee</code> will run sequentially. If any truth test returns <code>true</code> the promise is
immediately resolved.</p>
<p>In case of exception in one of the iteratee calls the promise returned by this function will be
rejected with the exception and the remaining pending tasks will be cancelled.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterable or async iterable object.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iteratee</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function that will be called with each member of the iterable. It will receive
three arguments:</p>
<ul>
<li><code>value</code>: The current value to process</li>
<li><code>index</code>: The index in the iterable. Will start from 0.</li>
<li><code>iterable</code>: The iterable on which the operation is being performed.</li>
</ul></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="someSeries.mjs.html">someSeries.mjs</a>, <a href="someSeries.mjs.html#line34">line 34</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved to <code>true</code> if at least one value pass the truth test and <code>false</code>
if none of them do. That promise will be rejected if one of the truth test throws an exception.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;boolean></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { someSeries, sleep } from 'modern-async'

const array = [1, 2, 3]

const result = await someSeries(array, async (v) => {
  // these calls will be performed sequentially
  await sleep(10) // waits 10ms
  return v % 2 === 0
})
console.log(result) // prints true
// total processing time should be ~ 20ms</code></pre>

    </div>


        
            

    

    <h4 class="name" id="timeout">
        <a href="#timeout">#</a>
        <span class="type-signature">(async) </span>timeout<span class="signature">(fct, amount)</span><span class="type-signature"> &rarr; {Promise}</span>
    </h4>

    



    <div class="description">
        <p>Wraps a call to an asynchronous function to add a timer on it. If the delay is exceeded
the returned promise will be rejected with a <code>TimeoutError</code>.</p>
<p>This function uses <code>setTimeout()</code> internally and has the same behavior, notably that it could reject
after the asked time (depending on other tasks running in the event loop) or a few milliseconds before.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fct</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>An asynchronous function that will be called immediately without arguments.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>amount</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>An amount of time in milliseconds</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="timeout.mjs.html">timeout.mjs</a>, <a href="timeout.mjs.html#line37">line 37</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved or rejected according to the result of the call
to <code>fct</code>. If <code>amount</code> milliseconds pass before the call to <code>fct</code> returns or rejects, this promise will
be rejected with a <code>TimeoutError</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise</span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { timeout, sleep } from 'modern-async'

// the following statement will perform successfully because
// the function will return before the delay
await timeout(async () => {
  await sleep(10)
}, 100)

try {
  // the following statement will throw after 10ms
  await timeout(async () => {
    await sleep(100)
  }, 10)
} catch (e) {
  console.log(e.name) // prints TimeoutError
}</code></pre>

    </div>


        
            

    

    <h4 class="name" id="timeoutPrecise">
        <a href="#timeoutPrecise">#</a>
        <span class="type-signature">(async) </span>timeoutPrecise<span class="signature">(fct, amount)</span><span class="type-signature"> &rarr; {Promise}</span>
    </h4>

    



    <div class="description">
        <p>Wraps a call to an asynchronous function to add a timer on it. If the delay is exceeded
the returned promise will be rejected with a <code>TimeoutError</code>.</p>
<p>This function is similar to <code>timeout()</code> except it ensures that the amount of time measured
using the <code>Date</code> object is always greater than or equal the asked amount of time.</p>
<p>This function can imply additional delay that can be bad for performances. As such it is
recommended to only use it in unit tests or very specific cases. Most applications should
be adapted to work with the usual <code>setTimout()</code> inconsistencies even if it can trigger some
milliseconds before the asked delay.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fct</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>An asynchronous function that will be called immediately without arguments.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>amount</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>An amount of time in milliseconds</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="timeoutPrecise.mjs.html">timeoutPrecise.mjs</a>, <a href="timeoutPrecise.mjs.html#line42">line 42</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>A promise that will be resolved or rejected according to the result of the call
to <code>fct</code>. If <code>amount</code> milliseconds pass before the call to <code>fct</code> returns or rejects, this promise will
be rejected with a <code>TimeoutError</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise</span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { timeoutPrecise, sleep } from 'modern-async'

// the following statement will perform successfully because
// the function will return before the delay
await timeoutPrecise(async () => {
  await sleep(10)
}, 100)

try {
  // the following statement will throw after 10ms
  await timeoutPrecise(async () => {
    await sleep(100)
  }, 10)
} catch (e) {
  console.log(e.name) // prints TimeoutError
}</code></pre>

    </div>


        
            

    

    <h4 class="name" id="toArray">
        <a href="#toArray">#</a>
        <span class="type-signature">(async) </span>toArray<span class="signature">(iterable)</span><span class="type-signature"> &rarr; {Promise.&lt;Array.&lt;any>>}</span>
    </h4>

    



    <div class="description">
        <p>Fully consumes an iteratable or async iterable an returns an array with all the elements it contained.</p>
    </div>









    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Parameters:</strong>
        

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">Iterable</span>
|

<span class="param-type">AsyncIterable</span>


            
            </td>

            

            

            <td class="description last"><p>An iterator or async iterator.</p></td>
        </tr>

    
    </tbody>
</table>

    </div>





<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
        <div class="details-item-container">
            <dt class="tag-source">Source:</dt>
            <dd class="tag-source"><ul class="dummy"><li>
                <a href="toArray.mjs.html">toArray.mjs</a>, <a href="toArray.mjs.html#line23">line 23</a>
            </li></ul></dd>
        </div>
    

    

    

    
</dl>













    <div class="method-member-container mt-20">
    <strong>Returns:</strong>
        
            
<div class="param-desc">
    <p>An array.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Promise.&lt;Array.&lt;any>></span>


    </dd>
</dl>

    </div>



    <div class="method-member-container flex flex-col w-100 overflow-auto mt-20">
        <strong>Example</strong>
        
    <pre class="prettyprint"><code>import { toArray, sleep } from 'modern-async'

// example async generator
async function* asyncGenerator() {
  for (let i = 0; i &lt; 3; i += 1) {
    await sleep(10)
    yield i
  }
}

console.log(await toArray(asyncGenerator()))
// prints [0, 1, 2]</code></pre>

    </div>


        
    

    

    
</article>

</section>




</div>

<footer id="footer">
  modern-async is licensed under the terms of the MIT license
</footer>

<script src="scripts/third-party/prettify.js"></script>
<script src="scripts/third-party/lang-css.js"></script>
<script src="scripts/search.js"></script>
<script src="scripts/third-party/fuse.js"></script>
<script type="text/javascript" src="scripts/misc.js"></script>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/fix-code-block.js"></script>
<script>
  var list = [{"title":"CancelledError","link":"<a href=\"CancelledError.html\">CancelledError</a>"},{"title":"Deferred","link":"<a href=\"Deferred.html\">Deferred</a>"},{"title":"Delayer","link":"<a href=\"Delayer.html\">Delayer</a>"},{"title":"Delayer#checkDelay","link":"<a href=\"Delayer.html#checkDelay\">Delayer &rtrif; checkDelay</a>"},{"title":"Delayer#reset","link":"<a href=\"Delayer.html#reset\">Delayer &rtrif; reset</a>"},{"title":"Queue","link":"<a href=\"Queue.html\">Queue</a>"},{"title":"Queue#cancelAllPending","link":"<a href=\"Queue.html#cancelAllPending\">Queue &rtrif; cancelAllPending</a>"},{"title":"Queue#exec","link":"<a href=\"Queue.html#exec\">Queue &rtrif; exec</a>"},{"title":"Queue#execCancellable","link":"<a href=\"Queue.html#execCancellable\">Queue &rtrif; execCancellable</a>"},{"title":"Scheduler","link":"<a href=\"Scheduler.html\">Scheduler</a>"},{"title":"Scheduler#start","link":"<a href=\"Scheduler.html#start\">Scheduler &rtrif; start</a>"},{"title":"Scheduler#stop","link":"<a href=\"Scheduler.html#stop\">Scheduler &rtrif; stop</a>"},{"title":"TimeoutError","link":"<a href=\"TimeoutError.html\">TimeoutError</a>"},{"title":"asyncIterableWrap","link":"<a href=\"global.html#asyncIterableWrap\">Global &rtrif; asyncIterableWrap</a>"},{"title":"asyncRoot","link":"<a href=\"global.html#asyncRoot\">Global &rtrif; asyncRoot</a>"},{"title":"asyncWrap","link":"<a href=\"global.html#asyncWrap\">Global &rtrif; asyncWrap</a>"},{"title":"delay","link":"<a href=\"global.html#delay\">Global &rtrif; delay</a>"},{"title":"delayCancellable","link":"<a href=\"global.html#delayCancellable\">Global &rtrif; delayCancellable</a>"},{"title":"every","link":"<a href=\"global.html#every\">Global &rtrif; every</a>"},{"title":"everyLimit","link":"<a href=\"global.html#everyLimit\">Global &rtrif; everyLimit</a>"},{"title":"everySeries","link":"<a href=\"global.html#everySeries\">Global &rtrif; everySeries</a>"},{"title":"filter","link":"<a href=\"global.html#filter\">Global &rtrif; filter</a>"},{"title":"filterGenerator","link":"<a href=\"global.html#filterGenerator\">Global &rtrif; filterGenerator</a>"},{"title":"filterLimit","link":"<a href=\"global.html#filterLimit\">Global &rtrif; filterLimit</a>"},{"title":"filterSeries","link":"<a href=\"global.html#filterSeries\">Global &rtrif; filterSeries</a>"},{"title":"find","link":"<a href=\"global.html#find\">Global &rtrif; find</a>"},{"title":"findIndex","link":"<a href=\"global.html#findIndex\">Global &rtrif; findIndex</a>"},{"title":"findIndexLimit","link":"<a href=\"global.html#findIndexLimit\">Global &rtrif; findIndexLimit</a>"},{"title":"findIndexSeries","link":"<a href=\"global.html#findIndexSeries\">Global &rtrif; findIndexSeries</a>"},{"title":"findLimit","link":"<a href=\"global.html#findLimit\">Global &rtrif; findLimit</a>"},{"title":"findSeries","link":"<a href=\"global.html#findSeries\">Global &rtrif; findSeries</a>"},{"title":"forEach","link":"<a href=\"global.html#forEach\">Global &rtrif; forEach</a>"},{"title":"forEachLimit","link":"<a href=\"global.html#forEachLimit\">Global &rtrif; forEachLimit</a>"},{"title":"forEachSeries","link":"<a href=\"global.html#forEachSeries\">Global &rtrif; forEachSeries</a>"},{"title":"map","link":"<a href=\"global.html#map\">Global &rtrif; map</a>"},{"title":"mapGenerator","link":"<a href=\"global.html#mapGenerator\">Global &rtrif; mapGenerator</a>"},{"title":"mapLimit","link":"<a href=\"global.html#mapLimit\">Global &rtrif; mapLimit</a>"},{"title":"mapSeries","link":"<a href=\"global.html#mapSeries\">Global &rtrif; mapSeries</a>"},{"title":"queueMicrotask","link":"<a href=\"global.html#queueMicrotask\">Global &rtrif; queueMicrotask</a>"},{"title":"reduce","link":"<a href=\"global.html#reduce\">Global &rtrif; reduce</a>"},{"title":"reduceRight","link":"<a href=\"global.html#reduceRight\">Global &rtrif; reduceRight</a>"},{"title":"sleep","link":"<a href=\"global.html#sleep\">Global &rtrif; sleep</a>"},{"title":"sleepCancellable","link":"<a href=\"global.html#sleepCancellable\">Global &rtrif; sleepCancellable</a>"},{"title":"sleepPrecise","link":"<a href=\"global.html#sleepPrecise\">Global &rtrif; sleepPrecise</a>"},{"title":"sleepPreciseCancellable","link":"<a href=\"global.html#sleepPreciseCancellable\">Global &rtrif; sleepPreciseCancellable</a>"},{"title":"some","link":"<a href=\"global.html#some\">Global &rtrif; some</a>"},{"title":"someLimit","link":"<a href=\"global.html#someLimit\">Global &rtrif; someLimit</a>"},{"title":"someSeries","link":"<a href=\"global.html#someSeries\">Global &rtrif; someSeries</a>"},{"title":"timeout","link":"<a href=\"global.html#timeout\">Global &rtrif; timeout</a>"},{"title":"timeoutPrecise","link":"<a href=\"global.html#timeoutPrecise\">Global &rtrif; timeoutPrecise</a>"},{"title":"toArray","link":"<a href=\"global.html#toArray\">Global &rtrif; toArray</a>"}];
  setupSearch(list)
</script>

 






</body>
</html>